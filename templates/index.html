<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Disk Extractor - Movie Metadata Manager</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/encoding.css') }}">
</head>
<body>
    <div class="header">
        <h1>Disk Extractor - Movie Metadata Manager</h1>
        <div class="header-actions">
            <a href="{{ url_for('settings') }}" class="settings-link">‚öôÔ∏è Settings</a>
        </div>
    </div>
    
    <!-- Disconnection Overlay -->
    <div id="disconnectionOverlay" class="disconnection-overlay hidden">
        <div class="disconnection-message">
            <div class="disconnection-icon">‚ö†Ô∏è</div>
            <h2>Connection Lost</h2>
            <p>Lost connection to server. Attempting to reconnect...</p>
            <div class="reconnection-spinner"></div>
        </div>
    </div>
    
    <div class="container">
        <div class="sidebar">
            <div class="sidebar-content">
                <ul class="file-list" id="fileList">
                    {% for movie in movies %}
                    <li class="file-item" data-filename="{{ movie.file_name }}" data-movie-index="{{ loop.index0 }}">
                        <!-- Content will be populated by JavaScript -->
                    </li>
                    {% endfor %}
                </ul>
            </div>
            
            <!-- Stats for Nerds section - Fixed at bottom -->
            <div id="statsForNerds" class="stats-for-nerds hidden">
                <div class="stats-header">
                    <h4>üìä Stats for Nerds</h4>
                    <button class="stats-close-btn" onclick="toggleStatsForNerds(false)" title="Close Stats">√ó</button>
                </div>
                <div id="statsContent" class="stats-content">
                    <div class="stats-loading">Loading...</div>
                </div>
            </div>
        </div>
        
        <div class="resizer" id="resizer"></div>
        
        <div class="main-content">
            <div id="emptyState" class="empty-state">
                <h2>Select a movie file to begin</h2>
                <p>Choose a file from the list on the left to view and edit its metadata.</p>
            </div>
            
            <div id="metadataForm" style="display: none;">
                <div class="file-info-section">
                    <h2 id="currentFileName">No file selected</h2>
                    <div class="file-actions-row">
                        <div class="file-size">
                            <span id="currentFileSize"></span>
                        </div>
                        <div class="action-buttons">
                            <button type="button" id="scanButton" onclick="scanFile()" class="action-button scan-button">
                                üîç Scan Media
                            </button>
                            <button type="button" id="rawOutputButton" onclick="showRawOutput()" class="action-button raw-output-button" style="display: none;">
                                üìÑ Raw Output
                            </button>
                        </div>
                    </div>
                    
                    <!-- Queue Management Section -->
                    <div class="queue-actions" id="queueActions">
                        <!-- Queue management buttons will be populated by JavaScript -->
                    </div>
                </div>
                
                <div id="enhancedMetadata" class="enhanced-metadata">
                    <div id="scanError" class="scan-error" style="display: none;">
                        <h3>‚ö†Ô∏è HandBrake Scan Error</h3>
                        <p id="scanErrorMessage"></p>
                        <button type="button" onclick="scanFile()" class="action-button scan-button">üîÑ Retry Scan</button>
                    </div>
                    
                    <div class="titles-container" id="titlesContainer">
                        <!-- Titles will be populated by JavaScript -->
                    </div>
                </div>
                
                <!-- Encoding History Section -->
                <div class="encoding-history" id="encodingHistory" style="display: none;">
                    <h4>Encoding History</h4>
                    <div id="historyContainer">
                        <!-- History items will be populated by JavaScript -->
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Raw Output Modal -->
    <div id="rawOutputModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>HandBrake Raw Output</h2>
                <span class="close" onclick="closeRawOutputModal()">&times;</span>
            </div>
            <div class="modal-body">
                <div id="rawOutputContent">
                    <!-- Content will be populated by JavaScript -->
                </div>
            </div>
        </div>
    </div>
    
    <!-- Minimal addition: notification area -->
    <div id="notifications" class="notifications"></div>
    
    <script>
        // Centralized file list item formatter
        function formatFileListItem(movie, encodingStatus = null) {
            // Determine CSS classes
            const classes = ['file-item'];
            
            if (movie.has_metadata) {
                classes.push('has-metadata');
            } else {
                classes.push('no-metadata');
            }
            
            if (encodingStatus && encodingStatus !== 'not_queued') {
                classes.push(encodingStatus);
            }
            
            // Build info text
            let infoText = '';
            if (movie.size_mb) {
                infoText = `${movie.size_mb} MB`;
            }
            
            if (movie.has_metadata) {
                infoText += infoText ? ' ‚Ä¢ Has metadata' : 'Has metadata';
            }
            
            if (encodingStatus && encodingStatus !== 'not_queued') {
                const statusMap = {
                    'queued': 'Queued',
                    'encoding': 'Encoding',
                    'completed': 'Completed',
                    'failed': 'Failed'
                };
                infoText += ` ‚Ä¢ ${statusMap[encodingStatus] || encodingStatus}`;
            }
            
            return {
                classes: classes.join(' '),
                fileName: movie.file_name,
                infoText: infoText,
                statusIndicatorClass: movie.has_metadata ? 'has-metadata' : 'no-metadata'
            };
        }
        
        // Populate a single file list item
        function populateFileListItem(listItem, movie, encodingStatus = null) {
            const format = formatFileListItem(movie, encodingStatus);
            
            // Set classes
            listItem.className = format.classes;
            listItem.onclick = () => selectFile(format.fileName);
            
            // Set content
            listItem.innerHTML = `
                <div class="file-name">
                    <span class="status-indicator ${format.statusIndicatorClass}"></span>
                    ${format.fileName}
                </div>
                <div class="file-info">
                    ${format.infoText}
                </div>
            `;
            
            // Add progress display for encoding files
            if (encodingStatus === 'encoding') {
                const progressDiv = createProgressDisplay(movie.file_name);
                listItem.appendChild(progressDiv);
            }
        }
        
        // Create progress display for encoding files
        function createProgressDisplay(fileName) {
            const progressDiv = document.createElement('div');
            progressDiv.className = 'encoding-progress';
            progressDiv.id = `progress-${fileName}`;
            
            // Progress bar
            const progressBarContainer = document.createElement('div');
            progressBarContainer.className = 'progress-bar-container';
            
            const progressBar = document.createElement('div');
            progressBar.className = 'progress-bar encoding';
            progressBar.style.width = '0%';
            
            progressBarContainer.appendChild(progressBar);
            progressDiv.appendChild(progressBarContainer);
            
            // Progress metrics
            const metricsDiv = document.createElement('div');
            metricsDiv.className = 'progress-metrics';
            
            // Percentage and phase
            const leftMetrics = document.createElement('div');
            leftMetrics.style.display = 'flex';
            leftMetrics.style.alignItems = 'center';
            leftMetrics.style.gap = '0.5rem';
            
            const percentageSpan = document.createElement('span');
            percentageSpan.className = 'progress-metric';
            percentageSpan.innerHTML = '<span class="metric-value">0%</span>';
            
            const phaseSpan = document.createElement('span');
            phaseSpan.className = 'encoding-phase scanning';
            phaseSpan.textContent = 'Scanning';
            
            leftMetrics.appendChild(percentageSpan);
            leftMetrics.appendChild(phaseSpan);
            
            // FPS and time metrics
            const rightMetrics = document.createElement('div');
            rightMetrics.style.display = 'flex';
            rightMetrics.style.gap = '1rem';
            
            const fpsSpan = document.createElement('span');
            fpsSpan.className = 'progress-metric';
            fpsSpan.innerHTML = '<span class="metric-label">FPS:</span> <span class="metric-value">0</span>';
            
            const timeSpan = document.createElement('span');
            timeSpan.className = 'progress-metric';
            timeSpan.innerHTML = '<span class="metric-label">ETA:</span> <span class="metric-value">--:--</span>';
            
            rightMetrics.appendChild(fpsSpan);
            rightMetrics.appendChild(timeSpan);
            
            metricsDiv.appendChild(leftMetrics);
            metricsDiv.appendChild(rightMetrics);
            progressDiv.appendChild(metricsDiv);
            
            return progressDiv;
        }
        
        // Make functions globally available for other modules
        window.formatFileListItem = formatFileListItem;
        window.populateFileListItem = populateFileListItem;
        window.createProgressDisplay = createProgressDisplay;
    </script>
    
    <script src="{{ url_for('static', filename='js/app.js') }}"></script>
    <script>
        // Initialize the app with movie data (this will call the original initializeApp from app.js)
        initializeApp({{ movies | tojson }});
        
        // After initialization, populate the file list with centralized formatting
        setTimeout(function() {
            const movies = {{ movies | tojson }};
            console.log('Populating file list with centralized formatting for', movies.length, 'movies');
            
            const fileListItems = document.querySelectorAll('#fileList .file-item');
            console.log('Found', fileListItems.length, 'file list items');
            
            fileListItems.forEach((item, index) => {
                const movieIndex = parseInt(item.dataset.movieIndex);
                const movie = movies[movieIndex];
                if (movie) {
                    console.log('Populating item', index, 'with movie:', movie.file_name);
                    populateFileListItem(item, movie);
                } else {
                    console.warn('No movie data for item', index);
                }
            });
            
            // Store movies data globally
            window.moviesData = movies;
        }, 50); // Small delay to let original initialization complete
    </script>
    
    <!-- WebSocket for real-time updates -->
    <script src="{{ url_for('static', filename='js/vendor/socket.io.js') }}"></script>
    <script>
        // Initialize WebSocket connection for file watching
        const socket = io();
        
        // Make socket available globally for encoding UI
        window.socket = socket;
        
        // Connection status handling
        socket.on('connect', function() {
            console.log('Connected to server');
            hideDisconnectionOverlay();
            
            // Initialize encoding UI after connection
            if (window.EncodingUI && typeof window.EncodingUI.initialize === 'function') {
                window.EncodingUI.initialize();
                console.log('Encoding UI initialized');
            } else {
                console.log('EncodingUI not available yet, will initialize when loaded');
            }
            
            // Request initial encoding status
            socket.emit('request_encoding_status');
        });
        
        socket.on('disconnect', function() {
            console.log('Disconnected from server');
            showDisconnectionOverlay();
        });
        
        // Encoding WebSocket event listeners
        socket.on('encoding_status_update', function(data) {
            console.log('üîÑ Encoding status update received:', data);
            if (window.EncodingUI) {
                window.EncodingUI.handleEncodingStatusUpdate(data);
            }
        });
        
        socket.on('encoding_progress', function(data) {
            console.log('üìä Encoding progress update received:', data);
            console.log('üìä Job ID:', data.job_id, 'Progress:', data.progress.percentage + '%');
            if (window.EncodingUI) {
                window.EncodingUI.handleEncodingProgress(data);
            } else {
                // Fallback if EncodingUI not loaded yet
                console.log('‚ö†Ô∏è EncodingUI not available, using fallback progress handler');
                handleEncodingProgressFallback(data);
            }
        });
        
        socket.on('encoding_status_change', function(data) {
            console.log('üîÑ Encoding status change received:', data);
            console.log('üîÑ Job ID:', data.job_id, 'Status:', data.status);
            if (window.EncodingUI) {
                window.EncodingUI.handleEncodingStatusChange(data);
            } else {
                // Fallback if EncodingUI not loaded yet
                console.log('‚ö†Ô∏è EncodingUI not available, using fallback status handler');
                handleEncodingStatusChangeFallback(data);
            }
        });
        
        // Fallback handlers for when EncodingUI is not loaded
        function handleEncodingProgressFallback(data) {
            const { job_id, progress } = data;
            const fileName = extractFileNameFromJobIdFallback(job_id);
            console.log(`Fallback: Progress update for ${fileName}: ${progress.percentage}%`);
            
            // Update progress display if it exists
            const progressDiv = document.getElementById(`progress-${fileName}`);
            if (progressDiv) {
                updateProgressDisplayFallback(progressDiv, progress);
            }
        }
        
        function handleEncodingStatusChangeFallback(data) {
            const { job_id, status } = data;
            const fileName = extractFileNameFromJobIdFallback(job_id);
            console.log(`Fallback: Status change for ${fileName}: ${status}`);
            
            // Update file list item status
            const fileItem = document.querySelector(`[data-filename="${CSS.escape(fileName)}"]`);
            if (fileItem) {
                updateFileItemStatusFallback(fileItem, status);
            }
        }
        
        function extractFileNameFromJobIdFallback(job_id) {
            const parts = job_id.split('_');
            if (parts.length >= 3) {
                return parts.slice(0, -2).join('_');
            }
            return job_id;
        }
        
        function updateProgressDisplayFallback(progressDiv, progress) {
            // Update progress bar
            const progressBar = progressDiv.querySelector('.progress-bar');
            if (progressBar) {
                progressBar.style.width = `${progress.percentage}%`;
            }
            
            // Update percentage
            const percentageSpan = progressDiv.querySelector('.progress-metric .metric-value');
            if (percentageSpan) {
                percentageSpan.textContent = `${progress.percentage.toFixed(1)}%`;
            }
            
            // Update phase
            const phaseSpan = progressDiv.querySelector('.encoding-phase');
            if (phaseSpan) {
                phaseSpan.className = `encoding-phase ${progress.phase}`;
                phaseSpan.textContent = progress.phase.charAt(0).toUpperCase() + progress.phase.slice(1);
            }
            
            // Update FPS and ETA
            const rightMetrics = progressDiv.querySelector('.progress-metrics > div:last-child');
            if (rightMetrics) {
                const fpsValue = rightMetrics.querySelector('.progress-metric:first-child .metric-value');
                if (fpsValue && progress.fps) {
                    fpsValue.textContent = progress.fps.toFixed(1);
                }
                
                const etaValue = rightMetrics.querySelector('.progress-metric:last-child .metric-value');
                if (etaValue && progress.time_remaining) {
                    const minutes = Math.floor(progress.time_remaining / 60);
                    const seconds = progress.time_remaining % 60;
                    etaValue.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                }
            }
        }
        
        function updateFileItemStatusFallback(fileItem, status) {
            // Remove existing status classes
            fileItem.classList.remove('queued', 'encoding', 'completed', 'failed');
            
            // Add new status class
            if (status && status !== 'not_queued') {
                fileItem.classList.add(status);
            }
            
            // Update file info text
            const fileInfo = fileItem.querySelector('.file-info');
            if (fileInfo) {
                let infoText = fileInfo.textContent;
                
                // Remove existing encoding status
                infoText = infoText.replace(/ ‚Ä¢ (Queued|Encoding|Completed|Failed)/g, '');
                
                // Add new encoding status
                if (status && status !== 'not_queued') {
                    const statusMap = {
                        'queued': 'Queued',
                        'encoding': 'Encoding',
                        'completed': 'Completed',
                        'failed': 'Failed'
                    };
                    infoText += ` ‚Ä¢ ${statusMap[status] || status}`;
                }
                
                fileInfo.textContent = infoText;
            }
        }
        
        // File list updates
        socket.on('file_list_update', function(data) {
            console.log('File list updated:', data.change_type, data.filename);
            updateFileList(data.movies);
            
            if (data.change_type && data.filename) {
                const messages = {
                    'added': `New movie file: ${data.filename}`,
                    'removed': `Movie file removed: ${data.filename}`,
                    'modified': `Movie file updated: ${data.filename}`,
                    'metadata_updated': `Metadata updated: ${data.filename}`
                };
                showNotification(messages[data.change_type] || 'Files updated', 'info');
            }
        });
        
        // Specific metadata updates for currently viewed movie
        socket.on('metadata_updated', function(data) {
            console.log('Metadata updated for:', data.filename);
            
            // Check if this is the currently selected/viewed movie
            if (typeof selectedFile !== 'undefined' && selectedFile === data.filename) {
                console.log('Refreshing current movie metadata');
                
                // Update the current movie data
                if (typeof currentMovies !== 'undefined') {
                    const movieIndex = currentMovies.findIndex(m => m.file_name === data.filename);
                    if (movieIndex !== -1) {
                        currentMovies[movieIndex] = data.movie_data;
                    }
                }
                
                // Refresh the metadata display for the current movie
                refreshCurrentMovieMetadata(data.movie_data);
                
                showNotification(`Metadata refreshed for ${data.filename}`, 'success');
            }
        });
        
        // Show/hide disconnection overlay
        function showDisconnectionOverlay() {
            const overlay = document.getElementById('disconnectionOverlay');
            if (overlay) {
                overlay.classList.remove('hidden');
                // Disable all interactive elements
                document.body.style.pointerEvents = 'none';
                overlay.style.pointerEvents = 'auto'; // Keep overlay interactive
            }
        }
        
        function hideDisconnectionOverlay() {
            const overlay = document.getElementById('disconnectionOverlay');
            if (overlay) {
                overlay.classList.add('hidden');
                // Re-enable all interactive elements
                document.body.style.pointerEvents = 'auto';
            }
        }
        
        // Update file list with new data (minimal implementation)
        function updateFileList(movies) {
            if (typeof currentMovies !== 'undefined') {
                currentMovies = movies;
            }
            
            const fileList = document.getElementById('fileList');
            const currentSelection = document.querySelector('.file-item.selected')?.dataset.filename;
            
            // Clear and rebuild list
            fileList.innerHTML = '';
            movies.forEach(movie => {
                const li = document.createElement('li');
                li.dataset.filename = movie.file_name;
                
                // Use centralized formatting
                populateFileListItem(li, movie);
                
                // Restore selection if needed
                if (movie.file_name === currentSelection) {
                    li.classList.add('selected');
                }
                
                fileList.appendChild(li);
            });
        }
        
        // Show notification (minimal implementation)
        function showNotification(message, type = 'info') {
            const notifications = document.getElementById('notifications');
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            
            notifications.appendChild(notification);
            
            // Auto-remove after 4 seconds
            setTimeout(() => {
                notification.remove();
            }, 4000);
        }
        
        // Refresh the metadata display for the currently viewed movie
        function refreshCurrentMovieMetadata(movieData) {
            try {
                // Update basic file info
                const fileNameElement = document.getElementById('currentFileName');
                const fileSizeElement = document.getElementById('currentFileSize');
                
                if (fileNameElement) {
                    fileNameElement.textContent = movieData.file_name;
                }
                
                if (fileSizeElement) {
                    fileSizeElement.textContent = movieData.size_mb ? `${movieData.size_mb} MB` : '';
                }
                
                // If there's a loadEnhancedMetadata function, call it to refresh the full metadata
                if (typeof loadEnhancedMetadata === 'function') {
                    console.log('Reloading enhanced metadata for updated file');
                    loadEnhancedMetadata(movieData.file_name);
                } else {
                    console.log('Enhanced metadata function not available, basic info updated');
                }
                
                // Update the file list item using centralized formatting
                const fileItem = document.querySelector(`[data-filename="${CSS.escape(movieData.file_name)}"]`);
                if (fileItem) {
                    const wasSelected = fileItem.classList.contains('selected');
                    
                    // Re-populate the item with centralized formatting
                    populateFileListItem(fileItem, movieData);
                    
                    // Restore selection if needed
                    if (wasSelected) {
                        fileItem.classList.add('selected');
                    }
                }
                
            } catch (error) {
                console.error('Error refreshing current movie metadata:', error);
            }
        }
        
        // Initialize with disconnection overlay shown
        showDisconnectionOverlay();
    </script>
    
    <!-- Encoding UI JavaScript -->
    <script src="{{ url_for('static', filename='js/encoding.js') }}"></script>
    <script>
        // Override selectFile to integrate with encoding UI
        const originalSelectFile = window.selectFile;
        window.selectFile = function(filename) {
            if (originalSelectFile) {
                originalSelectFile(filename);
            }
            
            // Update encoding UI
            if (window.EncodingUI) {
                window.EncodingUI.setSelectedFile(filename);
            }
        };
        
        // Override updateFileList to use encoding-aware version
        const originalUpdateFileList = window.updateFileList;
        window.updateFileList = function(movies) {
            // Store movies data for encoding UI
            window.moviesData = movies;
            
            // Use encoding-aware file list update
            if (window.EncodingUI) {
                window.EncodingUI.updateFileListWithEncodingStatus();
            } else {
                // Fallback to original if encoding UI not loaded
                if (originalUpdateFileList) {
                    originalUpdateFileList(movies);
                }
            }
        };
    </script>
</body>
</html>
